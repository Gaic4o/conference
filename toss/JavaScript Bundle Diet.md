# Toss Conference

[Javascript Bundle Diet](https://toss.im/slash-21/sessions/3-2)

웹사이트의 성능과 사용자 경험을 최적화하는 데 있어 **번들 사이즈**는 매우 중요한 요소입니다.

로딩 시간은 사용자의 이탈률에 직접적인 영향을 미치며, `연구에 따르면 로딩 시간이 2초 이내일 때의 이탈률은 약 9%인 반면, 5초를 초과하면 이탈률이 38%까지 증가한다고 합니다.`

이는 웹사이트의 로딩 속도가 사용자 만족도와 직결되어 있음을 의미합니다.

웹사이트의 속도를 결정짓는 요소 중 하나는 바로 자바스크립트(JS)의 번들 사이즈입니다.

JS 파일과 이미지 파일을 비교해보면, 이미지는 다운로드 후 단순히 디코딩만 하면 되는 반면, JS 파일은 여러 복잡한 과정을 거쳐야 합니다.
구체적으로, `JS 파일은 다운로드 후에 캐싱, 컴파일, 최종적으로 실행되기까지 여러 단계를 거치며, 이 과정에서 브라우저의 처리 비용이 상대적으로 더 많이 들게 됩니다.`
같은 크기의 이미지나 웹 폰트 파일에 비해 JS 파일이 브라우저의 처리 비용을 더 많이 요구하는 이유가 바로 이러한 복잡한 처리 과정 때문입니다.

따라서, 웹사이트의 로딩 속도를 향상시키고 사용자 경험을 개선하기 위해서는 JS 번들의 크기를 최적화하는 것이 매우 중요합니다.

#### 분석 도구

**Webpack Analyse**: 복잡한 사용법이지만, 다양한 분석 기능을 제공.
**Webpack Visualizer**: 깔끔한 시각화를 통해 번들의 구성을 이해하는 데 도움을 줍니다. 그러나 일부 기능이 부족할 수 있음.
**Webpack Bundle Analyzer**: 번들의 구성을 원인 분석에 유용한 시각화로 제공 해, 번들 사이즈 최적화의 출발점을 추천됩니다.

이러한 도구들은 번들의 용량별 구성을 시각화하여, 사용 중인 라이브러리의 크기와 사용 빈도를 명확히 보여줍니다.
이를 통해 용량이 큰 라이브러리를 더 가벼운 대체제로 교체하거나, 용도나 겹치는 라이브러리를 하나로 통합하는 등의 최적화 잡업을 시작할 수 있습니다.

#### NPM과 디펜던시 관리

NPM은 자바스크립트 패키지 관리자로, 라이브러리 간의 의존성을 관리합니다.
다만 다양한 라이브러리가 서로 다른 버전의 같은 의존성을 요구하는 경우(의존성 충돌), NPM은 tree 구조로 각각의 필요한 버전을 모두 설치합니다.
이는 개발자가 의도한 대로 각 라이브러리 올바른 버전의 의존성을 사용하게 하는 장점도 있지만, `node_modules` 폴더의 용량이 과도하게 커지는 단점도 있습니다.

#### Semver와 중복 의존성 문제

NPM은 시멘틱 버전(semver) 준수를 가정하며, 가능한 경우 더 높은 버전의 단일 의존성을 사용하여 중복을 줄입니다.
시멘틱 버전은 소프트웨어의 버전을 체계적으로 관리하기 위한 규칙으로, 하위 호환성을 보장하는 범위 내에서 더 높은 버정늘 사용해도 안전하다고 판단합니다.
그러나 이 방식이 항상 완벽하게 작동하는 것은 아니며, 떄로는 중복된 의존성으로인해 번들 사이즈가 불필요하게 커지는 경우도 발생합니다.

### 패캐지 의존성 관리

`npm`, `yarn` 은 라이브러리의 의존성 충돌을 해결하기 위해 각기 다른 접근 방식을 제공합니다.
npm 은 tree 구조를 사용해 필요한 모든 버전을 다운로드 하는 반면, yarn 은 설치 과정에서 의존성을 완벽하게 처리하려고 시도합니다.

중복된 라이브러리 버전을 발견할 경우, npm의 **dedupe** 기능을 이용해 중복을 줄이고, 더 적합한 버전으로 통합 가능합니다.

yarn 에서는 **yarn deduplicate** 을 사용해 중복된 라이브러리를 제거하고 최적화를 할 수 있습니다.

### 라이브러리 최적화와 대체

**Lodash** 와 같은 라이브러리는 다양한 버전과 모듈을 제공하며, 필요하지 않는 부분까지 번들에 포함되어 번들 사이즈를 불필요하게 늘릴 수 있습니다.
**Webpack** 의 `alias` 기능을 활용해 중복된 라이브러리 버전을 하나로 통합하거나, 필요한 부분만을 퐇마시키도록 최적화할 수 있습니다.
**babel-plugin-transform-imports** 를 이용해 사용 중인 함수나 모듈만을 선택적으로 가져오는 방식으로 번들 사이즈를 줄일 수 있습니다.

### Polyfill 추가와 그 영향

Webpack 은 브라우저와 Node.js 환경 간의 호환성을 위해 필요한 경우 polyfill 을 추가할 수 있습니다.
그러나 polyfill 이 추가되면 웹사이트의 로딩 시간에 영향을 줄 수 있습니다.
예를 들어, `node-rsa` 와 같은 라이브러리는 Node.js 전용으로 만들어졌기 떄문에, 브라우저에서 사용될 떄는 상당한 양의 polyfill 이 추가되어 번들 사이즈가 증가할 수 있습니다.

### 번들 사이즈 최적화를 위한 도구와 전략

번들포비아 : 라이브러리는 gzip 용량, 다운로드 속도, 각 버전별 용량을 쉽게 비교할 수 있게 해주는 웹사이트 입니다. 이는 라이버리를 선택 과정에서 중요 참고 자료가 될 수 있음.

[bundlephobia](https://bundlephobia.com/)
[사용하신 분 블로그 포스트 글](https://jsikim1.tistory.com/198)

Tree-shaking : 불 필요한 코드를 제거하여 번들 사이즈를 최적화 하는 기술, 하지만 모든 라이브러리가 tree-shaking 을 완벽하게 지원하는 것은 아니므로, 라이브러리 제작자는 rollup, webpack 등의 번들러가 이를 잘 수행 할 수 있도록 해줘야 합니다.

Webpack 의 `alias` 기능과 **babel-plugin-transform-imports** 를 활용하여 필요한 코드만 번들에 포함시키도록 최적화할 수 있습니다.

### 청크 분할과 초기 로딩 속도 개선

토스팀의 경험에서, 특정 라이브러리를 사용할 떄 모든 페이지의 용량이 증가하는 문제를 청크 분할을 통해 해결 할 수 있었습니다.
webpack 의 magic comment 를 사용해 dynamic import 와 함께 prefetch 기능을 활용하면, 사용자에게 최소한의 지연 시간으로 필요한 자원을 제공할 수 있습니다.

```javascript
import dynamic from "next/dynamic";

const PageA = dynamic(() => import("./PageA"));
const PageB = dynamic(() => /* webpackPrefetch: true */ import("./PageB"));
```

이러한 접근 방식은 청크를 나누어 라이브러리를 사용하는 페이지에서만 해당 라이브러리를 로드하게 하여, 초기 로딩 속도 개선, 사용자 경험을 최적화 할 수 있습니다.

### 정리

일단 번들러 Webpack, 패키지 매니저 Npm 을 사용한다고 가정한다면,
일단 Webpack 번들 용량별 구성의 시각화를 통해 라이브러리 크기와 사용 빈도를 통해,
중복 된 라이브러리가 있으면, 용량이 적은 라이브러리로 사용하거나, 용량이 큰 라이브러리가 있으면 더 가벼운 것으로 대체하거나 최적화 작업을 하기.

npm 은 의존성 설치로 tree 구조로 라이브러리 하나를 설치하면, 그 자식 라이브러리가 tree 구조로 설치가 됩니다. 이 과정에서 라이브러리 여러 개를 npm install 하면, 하위 tree 에 서로 중복된 라이브러리 설치되고 이런 것들이 node_modules 용량이 과도하게 커질 수 있습니다.

그래서 npm dedupe 기능을 이용해 중복된 라이브러리 버전을 중복을 줄일 수 있음. 또는 Tree-shaking 을 적용해, 사용하지 않는 불필요한 코드 제거.
그리고 모든 페이지 중 용량이 큰 부분은 청크로 분할해 용량 줄이기.
